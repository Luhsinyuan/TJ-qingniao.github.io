<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Be Better
    </title>
    <meta name="description" content= My personal blog. >
    <meta name="keywords" content= Blog,Hexo >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            数据库复习
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="数据库复习"><a href="#数据库复习" class="headerlink" title="数据库复习"></a>数据库复习</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><h3 id="数据抽象的三个层次"><a href="#数据抽象的三个层次" class="headerlink" title="数据抽象的三个层次"></a>数据抽象的三个层次</h3><p><strong>物理层，逻辑层，视图层。</strong></p>
<h3 id="数据模型的定义和分类"><a href="#数据模型的定义和分类" class="headerlink" title="数据模型的定义和分类"></a>数据模型的定义和分类</h3><p><strong>数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。</strong></p>
<p><strong>可被分为四类：关系模型，实体-联系模型，基于对象的数据模型，半结构化数据模型。</strong></p>
<h3 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h3><p><strong>DML：数据操纵语言，使得用户可以访问或操纵那些按照某些适当的数据结构组织起来的数据。</strong></p>
<p><strong>DDL:数据定义语言。</strong></p>
<h2 id="2-关系模型介绍"><a href="#2-关系模型介绍" class="headerlink" title="2. 关系模型介绍"></a>2. 关系模型介绍</h2><h3 id="关系模型的基本介绍"><a href="#关系模型的基本介绍" class="headerlink" title="关系模型的基本介绍"></a>关系模型的基本介绍</h3><p><strong>关系用来指代表，元组指代一行数据，属性表示表中的列。</strong></p>
<p><strong>关系实例表示一个关系的特定实例。</strong></p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p><strong>超码，候选码，主码，外码。</strong></p>
<p><strong>大学关系模式图（牢记）</strong></p>
<p><strong>关系的运算</strong></p>
<h2 id="3-SQL"><a href="#3-SQL" class="headerlink" title="3. SQL"></a>3. SQL</h2><h3 id="注意的考点"><a href="#注意的考点" class="headerlink" title="注意的考点"></a>注意的考点</h3><p><strong>用/不用with结构改写sql语句</strong></p>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="注意的考点-1"><a href="#注意的考点-1" class="headerlink" title="注意的考点"></a>注意的考点</h3><p><strong>找出分组后的最大值之后，再让你找出拥有最大值的元组的某一属性，可以用自然连接。</strong></p>
<p><strong>譬如：当找出教师的最高工资后，再让你找出拥有最高工资的教师，就可以直接讲教师的关系和前文中求出的最高工资的属性自然连接，自然连接后得到的就是拥有最高工资的老师。</strong></p>
<p><strong>用$\Join$$\theta$来表示在规定属性上的自然连接，即join on</strong></p>
<p><strong>用关系代数需要找最大值是用聚集函数书法体G，但是找最大值的元组，一般是总体减去部分，即总体的元组减去非最大值的元组。</strong></p>
<h2 id="4-数据库设计与E-R模型"><a href="#4-数据库设计与E-R模型" class="headerlink" title="4. 数据库设计与E-R模型"></a>4. 数据库设计与E-R模型</h2><p>实体可以理解为，真实存在的物体；实体集就是实体的集合。</p>
<p>属性就是实体的列，每个属性会有一个值。</p>
<p>联系是指多个实体之间的相互关联。联系集是相同类型联系的集合。</p>
<p>实体集之间的关联称为参与，实体在联系中扮演的功能称为实体的角色。</p>
<p>参与联系集的实体集的数目称为联系集的度。</p>
<h3 id="E-R图中的属性"><a href="#E-R图中的属性" class="headerlink" title="E-R图中的属性"></a>E-R图中的属性</h3><ul>
<li>简单属性和符合属性</li>
</ul>
<p>复合属性可以划分为更小的部分，譬如，一个name属性可以再被划分为first_name,middle_name,last_name等</p>
<ul>
<li>单值属性和多值属性</li>
</ul>
<p>对于特定的实体而言，一个属性或许有多个取值，这样的属性称为是多值的。用花括号{}括起来表示该属性是多值的。</p>
<ul>
<li>派生属性</li>
</ul>
<p>该属性的值可以由别的相关属性或实体派生出来。譬如年龄可以由当前日期和出生日期得到。</p>
<h3 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h3><p>表示一个实体通过一个联系集能关联的实体的个数。</p>
<ul>
<li>一对一</li>
</ul>
<p>A中实体至多与B中的一个实体有关联，B中一个实体也最多与A中的一个实体相关联。</p>
<ul>
<li>多对一</li>
</ul>
<p><em>多方</em>的一个实体最多与<em>一方</em>的一个实体相关联，<em>一方</em>的一个实体可以与<em>多方</em>的任意多个实体相关联。</p>
<ul>
<li>多对多</li>
</ul>
<p>A中的一个实体可以与B中的任意多个实体相关联，反之亦然。</p>
<p>譬如：教师可以教多个学生，每个学生只能有一个老师，则再此关系中，老师为一方，可以和学生实体集中任意多个学生有教导的关系，而学生作为多方，只能与老师实体集中的一个老师有教导关系。</p>
<h3 id="参与约束"><a href="#参与约束" class="headerlink" title="参与约束"></a>参与约束</h3><p>如果实体集E中的每个实体都参与到联系集R的至少一个练习中，则称实体集E在联系集R中的参与是<em>全部</em>的，如果只有一部分参与，则称之为<em>部分</em>的。</p>
<h3 id="码-1"><a href="#码-1" class="headerlink" title="码"></a>码</h3><p>对于任意的联系集，其属性为本身属性并上参与其的实体集的主码。<br>联系集的主码则依赖于映射基数。</p>
<ul>
<li>一对一时，任意一个实体集的候选码都可以作为主码。</li>
<li>多对一时，多方的主码作为联系集的主码。</li>
<li>多对多时，两个实体集的主码的并作为联系集的主码。</li>
</ul>
<h3 id="从实体集中删除冗余属性"><a href="#从实体集中删除冗余属性" class="headerlink" title="从实体集中删除冗余属性"></a>从实体集中删除冗余属性</h3><p>简而言之，两个有关系的实体集，若有属性重复，将不是主码的属性在其实体集中删除。</p>
<h3 id="E-R图的画法"><a href="#E-R图的画法" class="headerlink" title="E-R图的画法"></a>E-R图的画法</h3><ul>
<li>基本结构</li>
</ul>
<p>矩形，菱形，线段，虚线，双线，双菱形。</p>
<ul>
<li>映射基数</li>
</ul>
<p>一方加箭头，也可以将映射基数写在线段上，形式为<em>l..h</em></p>
<p>l表示最小的映射基数，h表示最大的映射基数。</p>
<p>譬如instructor与student之间有一个advisor的关系，若instructor的映射基数是<em>0..*</em></p>
<p>表示老师在这个关系中可以0参与，也可以多个参与。</p>
<p>student的映射基数为<em>1..1</em></p>
<p>表示学生在这个关系中必须参与一次，并且最多参与一次</p>
<p>翻译过来就是，学生与老师的关系是多对一的。</p>
<ul>
<li><p>复杂属性的结构</p>
</li>
<li><p>角色</p>
</li>
<li><p>非二元的联系集，箭头只允许出现一个</p>
</li>
</ul>
<h3 id="弱实体集"><a href="#弱实体集" class="headerlink" title="弱实体集"></a>弱实体集</h3><ul>
<li>定义</li>
</ul>
<p>指没有足够的属性形成主码的实体集叫做弱实体集。有主码的实体集称为强实体集。</p>
<p>弱实体集必须与一个标识/属主实体集相关联，即弱实体集<em>存在依赖</em>于标识实体集。标识实体集<em>拥有</em>弱实体集。<br>将二者之间的联系称为<em>标识性联系</em></p>
<ul>
<li>分辨符</li>
</ul>
<p>弱实体集区分属性的属性集合，也叫做部分码，用虚线表示。</p>
<ul>
<li>弱实体集和强实体集之间的联系集用双菱形表示</li>
</ul>
<h3 id="转化为关系模式"><a href="#转化为关系模式" class="headerlink" title="转化为关系模式"></a>转化为关系模式</h3><h3 id="特化概化"><a href="#特化概化" class="headerlink" title="特化概化"></a>特化概化</h3><h2 id="5-关系数据库设计"><a href="#5-关系数据库设计" class="headerlink" title="5. 关系数据库设计"></a>5. 关系数据库设计</h2><h3 id="好的关系设计"><a href="#好的关系设计" class="headerlink" title="好的关系设计"></a>好的关系设计</h3><ul>
<li>更大的模式</li>
</ul>
<p>产生冗余</p>
<ul>
<li>更小的模式</li>
</ul>
<p>冗余较少</p>
<h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul>
<li>定义</li>
</ul>
<p>形如a$\rightarrow$的表示，被称为a函数决定b，其中a和b都为属性。含义为，若t1[a]=t2[a],则t1[b]=t2[b].</p>
<ul>
<li>作用</li>
</ul>
<ol>
<li>判断关系的实例是否满足函数依赖集F</li>
<li>说明合法关系集上的约束</li>
</ol>
<ul>
<li>平凡的函数依赖</li>
</ul>
<p>如果b$\subseteq$a,则称a$\rightarrow$b是平凡的。</p>
<h3 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h3><p>将一个关系r分解为r1和r2，如果r1$\Join$r2=r，则称之为无损分解。</p>
<ul>
<li>检测方法</li>
</ul>
<p>R1和R2是R的无损分解，如果一下任意函数依赖至少有一个属于F+：</p>
<p>R1$\cap$R2$\rightarrow$R1</p>
<p>R1$\cap$R2$\rightarrow$R2</p>
<p>即R1$\cap$R2是R1或者R2的超码</p>
<h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>关系R的所有属性的域都是原子的。</p>
<h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>具有函数依赖集F的关系模式R满足BCNF的条件是，对于F+中所有形如$\alpha$$\rightarrow$$\beta$,下边至少有一项成立：</p>
<ul>
<li>$\alpha$$\rightarrow$$\beta$是平凡的</li>
<li>$\alpha$是模式R的一个超码</li>
</ul>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>由于BCNF的分解往往不是保持依赖的，因此我们引入了3NF</p>
<p>具有函数依赖集F的关系模式R满足3NF的条件是，对于F+中所有形如$\alpha$$\rightarrow$$\beta$,下边至少有一项成立：</p>
<ul>
<li>$\alpha$$\rightarrow$$\beta$是平凡的</li>
<li>$\alpha$是模式R的一个超码</li>
<li>$\beta$-$\alpha$中的每个属性A都包含于R的一个候选码中</li>
</ul>
<h3 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h3><p>F的闭包是被F逻辑蕴含的所有函数依赖的集合，称为F+</p>
<ul>
<li>Armstrong公理</li>
</ul>
<p>自反率</p>
<p>增补率</p>
<p>传递率</p>
<p>引申出的规则</p>
<p>合并率</p>
<p>分解率</p>
<p>传递率</p>
<ul>
<li>计算F+的算法</li>
</ul>
<p>首先在F上用自反率和增补率，将结果加入到F+中，然后对F+中的任意一对函数依赖，使用传递率结合起来，将其加入到F+中。</p>
<h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><p>令$\alpha$为一个属性集，函数依赖集F下被$\alpha$函数决定的所有属性的集合称为F下$\alpha$的闭包。记作$\alpha$+</p>
<ul>
<li>算法</li>
</ul>
<h3 id="属性集闭包的作用"><a href="#属性集闭包的作用" class="headerlink" title="属性集闭包的作用"></a>属性集闭包的作用</h3><ul>
<li>判断一个属性是否为超码</li>
<li>判断$\alpha$$\rightarrow$$\beta$是否成立</li>
<li>计算F+的另一种算法</li>
</ul>
<h3 id="正则覆盖"><a href="#正则覆盖" class="headerlink" title="正则覆盖"></a>正则覆盖</h3><p>F的正则覆盖Fc是一个依赖集，使得F逻辑蕴含Fc中的所有依赖，并且反之亦然。<br>Fc有以下性质：</p>
<ul>
<li>Fc中任何函数依赖都没有无关属性</li>
<li>Fc中左半边都是唯一的</li>
</ul>
<h3 id="保持依赖"><a href="#保持依赖" class="headerlink" title="保持依赖"></a>保持依赖</h3><p>若F中的每一个函数依赖都可以在分解得到的某一个关系上验证，而不需要合并，那么这个分解是保持依赖的，反之则不一定。</p>
<p>一般性的验证方法：</p>
<h3 id="分解算法"><a href="#分解算法" class="headerlink" title="分解算法"></a>分解算法</h3><ul>
<li>BCNF分解</li>
</ul>
<p>对于整个F的每一个函数依赖，先判断该函数依赖是不是满足BCNF要求，若不满足，将其分解，分解后要将原先的F中的函数依赖通过Armstrong定理和引申出的规则进行合并，将只包含分解后属性的函数依赖在各自的关系上验证。</p>
<ul>
<li>3NF分解</li>
</ul>
<p>先求Fc，求完之后对于Fc中的任意一个函数依赖，将其分解为一个关系，如果所有的分解后的关系中都不包含R的候选码，则将R的候选吗单独弄成一个关系。</p>
<ul>
<li>4NF分解</li>
</ul>
<h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><h3 id="候选码求法"><a href="#候选码求法" class="headerlink" title="候选码求法"></a>候选码求法</h3><p>将所有属性分为4类</p>
<ul>
<li>L</li>
</ul>
<p>表示该属性只在左边出现</p>
<ul>
<li>R</li>
</ul>
<p>表示该属性只在右边出现</p>
<ul>
<li>LR</li>
</ul>
<p>表示该属性既在左边还在右边出现</p>
<ul>
<li>N</li>
</ul>
<p>表示该属性没有出现</p>
<p>令X=L$\cup$N,Y=LR,求X的闭包，倘若X的闭包包含了R的所有属性，则X是R的唯一候选码，此时结束。若不是，则从Y中选取任意一个属性A，求XA的闭包，若包含所有属性，则是候选码，调换不同属性，一个一个实验，直至实验完Y中的所有属性.此时若Y中的属性没有被选完，那么再两个两个试，试完Y中的属性。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Xi4y1b7HY">视频链接</a></p>
<h2 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h2><h2 id="索引与散列"><a href="#索引与散列" class="headerlink" title="索引与散列"></a>索引与散列</h2><h3 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h3><ul>
<li>顺序索引</li>
</ul>
<ol>
<li><p>聚集索引：文件按照搜索码的顺序排列，该搜索码对应的索引叫做聚集索引。</p>
</li>
<li><p>非聚集索引：搜索码指定的顺序与文件中记录的物理顺序不同的索引，又叫辅助索引</p>
</li>
<li><p>稠密索引：每个搜索码对应一个索引值</p>
</li>
<li><p>稀疏索引：只为某些搜索码建立索引项，只有聚集索引可以使用稀疏索引，换句话说，辅助索引一定是稠密索引。</p>
</li>
<li><p>多级索引</p>
</li>
<li><p>索引插入：</p>
<ol>
<li><p>对于稠密索引，如果没有该搜索码，就插入到合适的位置，如果有该搜索码</p>
<p>  a. 如果存储的是具有相同搜索码的所有记录的指针，那么就新加入要插入搜索码的指针<br>  b. 如果存储的是具有相同搜素码的第一条记录的指针，那么就把该指针放入到所有相同搜索码记录的后边.</p>
</li>
</ol>
</li>
<li><p>对于稀疏索引，如果没有新增块，不做改变，如果新增块了，将最小值添加到稀疏索引中，如果改变了块内的最小值，将对应的索引值改变。</p>
</li>
<li><p>索引删除：</p>
<ol>
<li>对于稠密索引，与插入类似</li>
<li>对于稀疏索引，如果索引中不包含被删除项，不做改变，否则  a. 如果被删除记录是该搜索码的唯一记录，系统用下一个搜索码替换掉原来的索引，作为新的索引值，假如下一条搜索码已经是索引项，那么删除该索引项，无需替换<br>  b. 如果不是唯一的记录，将指针指向具有相同搜索码的下一条记录。</li>
</ol>
</li>
<li><p>B+树</p>
<ol>
<li>分裂时，前边是$\frac{n+1}{2}$向上取整个，剩下的给后边，这是对于插入而言</li>
<li> 每个非叶节点，有$\frac{n}{2}$~n个<em>子女</em></li>
<li> 每个非叶节点容纳$\frac{n}{2}$~n个指针</li>
<li> 每个叶节点容纳$\frac{n-1}{2}$~n-1个搜索码</li>
</ol>
</li>
<li><p>散列索引</p>
<ol>
<li>静态散列</li>
</ol>
<ul>
<li>散列函数</li>
</ul>
<p>指一个从搜索码到桶地址的函数</p>
<ul>
<li>桶溢出</li>
</ul>
<p>一般有两种情况：  </p>
<pre><code>    a .桶不足  
    b.偏斜
</code></pre>
<p>用溢出桶来解决</p>
<ul>
<li>散列索引</li>
</ul>
<p>只能用来表示辅助索引</p>
<ul>
<li>动态散列</li>
</ul>
<p>允许散列函数动态改变，以适应数据库增大或者缩小的需要。</p>
<ul>
<li>静态散列与动态散列比较</li>
</ul>
<p>可扩充散列最主要的优点是其性能不随文件的增长而降低，空间开销是最小的。缺点在于查询涉及一个附加的间接层。</p>
</li>
</ol>
<p>位图索引</p>
<h2 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h2><ol>
<li>查询处理步骤</li>
</ol>
<ul>
<li>语法分析与翻译</li>
<li>优化</li>
<li>执行</li>
</ul>
<ol start="2">
<li>查询代价的度量</li>
</ol>
<ul>
<li><p>查询处理的代价可以通过该查询对各资源的使用情况进行度量，包括磁盘存取，执行一个查询所用的CPU时间，还有再并行/分布式数据库系统中的通信代价。</p>
</li>
<li><p>为了简化，仅仅使用磁盘存取代价来度量查询执行计划的代价，用传送磁盘以及搜索磁盘次数来度量查询计算计划</p>
</li>
</ul>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Lu Xinyuan | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
